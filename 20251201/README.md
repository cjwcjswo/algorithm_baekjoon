# 2025년 12월 1일 문제 풀이 정리

## 📚 학습 내용 요약

### 1. 수학적 계산 및 패턴 분석

#### 문제: 2869 (달팽이는 올라가고 싶다)
- **핵심 문법**: 나눗셈과 나머지 연산, 수학적 공식 도출
- **학습 포인트**:
  - 달팽이가 낮에 A미터 올라가고 밤에 B미터 내려가는 문제
  - 마지막 날은 미끄러지지 않으므로 (V-A)까지 도달하는 날 수 계산
  - 수학적 공식: `⌈(V-A)/(A-B)⌉ + 1`
  - 올림 처리를 위한 조건문 활용

**개선된 코드 예시**:
```python
# 2869번 - 달팽이는 올라가고 싶다 (더 간결한 버전)
a, b, v = map(int, input().split())

if a >= v:
    print(1)
else:
    # (v - a)까지 도달하는 데 걸리는 날 수
    days = (v - a) // (a - b)
    # 나머지가 있으면 하루 더 필요
    if (v - a) % (a - b) == 0:
        print(days + 1)
    else:
        print(days + 2)

# 또는 math.ceil 활용
import math
a, b, v = map(int, input().split())
if a >= v:
    print(1)
else:
    print(math.ceil((v - a) / (a - b)) + 1)

# 가장 간결한 버전
a, b, v = map(int, input().split())
print((v - b - 1) // (a - b) + 1)  # 올림 처리를 위한 트릭
```

### 2. 패턴 분석 및 수열

#### 문제: 1193 (분수찾기)
- **핵심 문법**: 수열 패턴 분석, 대각선 그룹 찾기
- **학습 포인트**:
  - 분수 배열을 대각선으로 그룹화
  - 각 그룹의 시작 번호: 1, 2, 4, 7, 11, ... (삼각수 + 1)
  - 그룹 번호에 따라 분자/분모 계산 방식이 다름
  - 짝수 그룹: 오른쪽 위 → 왼쪽 아래
  - 홀수 그룹: 왼쪽 아래 → 오른쪽 위

**개선된 코드 예시**:
```python
# 1193번 - 분수찾기 (더 간결한 버전)
x = int(input())

# 대각선 그룹 찾기
group = 1
start = 1
while start + group <= x:
    start += group
    group += 1

# 그룹 내에서의 위치
pos = x - start

if group % 2 == 0:  # 짝수 그룹: 오른쪽 위 → 왼쪽 아래
    numerator = pos + 1
    denominator = group - pos
else:  # 홀수 그룹: 왼쪽 아래 → 오른쪽 위
    numerator = group - pos
    denominator = pos + 1

print(f"{numerator}/{denominator}")

# 또는 더 간결하게
x = int(input())
group = 1
while group * (group + 1) // 2 < x:
    group += 1

pos = x - group * (group - 1) // 2 - 1
if group % 2 == 0:
    print(f"{pos + 1}/{group - pos}")
else:
    print(f"{group - pos}/{pos + 1}")
```

### 3. 기하학적 패턴 분석

#### 문제: 2292 (벌집)
- **핵심 문법**: 수열 패턴 분석, 등차수열 합
- **학습 포인트**:
  - 벌집의 중심에서 각 레이어까지의 최소 거리 계산
  - 각 레이어의 방 개수: 6, 12, 18, 24, ... (등차수열)
  - 각 레이어의 시작 번호: 1, 2, 8, 20, 38, ...
  - 공식: n번째 레이어 시작 번호 = 3n² - 3n + 2

**개선된 코드 예시**:
```python
# 2292번 - 벌집 (더 간결한 버전)
n = int(input())

if n == 1:
    print(1)
else:
    layer = 1
    while True:
        # layer번째 레이어의 시작 번호
        start = 3 * layer * layer - 3 * layer + 2
        # layer번째 레이어의 끝 번호
        end = start + 6 * layer - 1
        
        if start <= n <= end:
            print(layer + 1)
            break
        layer += 1

# 또는 수학적 공식 활용
n = int(input())
if n == 1:
    print(1)
else:
    # n이 속한 레이어 찾기: 3k² - 3k + 2 <= n <= 3k² + 3k + 1
    # 이를 역으로 계산하면 k = ⌈(√(12n-3) - 3) / 6⌉
    import math
    k = math.ceil((math.sqrt(12 * n - 3) - 3) / 6)
    print(k + 1)
```

## 🎯 핵심 파이썬 문법 정리

### 1. 수학적 계산
- **올림 처리**: 
  - `math.ceil()` 함수 활용
  - 또는 `(n + m - 1) // m` 형태로 올림 구현
- **나머지 연산**: 
  - `%` 연산자로 나머지 계산
  - 나머지가 0인지 확인하여 추가 처리 필요 여부 판단

### 2. 패턴 분석
- **수열 패턴 찾기**:
  1. 작은 케이스부터 분석
  2. 규칙 찾기
  3. 공식 도출
  4. 일반화
- **등차수열/등비수열**: 
  - 등차수열 합: n(a + l) / 2
  - 등비수열 합: a(rⁿ - 1) / (r - 1)

### 3. 반복문과 조건문
- **while True**: 
  - 조건을 만족할 때까지 반복
  - break로 탈출
- **조건부 계산**: 
  - 패턴에 따라 다른 계산 방식 적용

## 💡 효율성 개선 팁

1. **수학적 공식 활용**:
   - 반복문 대신 수학적 공식으로 직접 계산
   - 시간 복잡도 O(1)로 개선 가능

2. **올림 처리**:
   - `math.ceil()` 함수 활용
   - 또는 정수 연산으로 올림 구현: `(n + m - 1) // m`

3. **패턴 분석**:
   - 작은 케이스부터 차근차근 분석
   - 수열의 일반항을 찾으면 코드가 간단해짐

4. **조건문 최적화**:
   - 특수 케이스(예: n == 1)를 먼저 처리
   - 불필요한 반복 제거

## 🔍 문제별 핵심 포인트

### 2869번 (달팽이는 올라가고 싶다)
- **핵심**: 마지막 날은 미끄러지지 않는다는 점
- **주의**: 올림 처리가 필요함
- **팁**: `(v - b - 1) // (a - b) + 1` 형태로 올림 구현

### 1193번 (분수찾기)
- **핵심**: 대각선 그룹으로 분수 배열을 나눔
- **주의**: 그룹 번호의 홀짝에 따라 분자/분모 계산 방식이 다름
- **팁**: 삼각수 공식 활용: n(n+1)/2

### 2292번 (벌집)
- **핵심**: 각 레이어의 방 개수가 등차수열
- **주의**: n=1인 경우 별도 처리
- **팁**: 레이어 시작 번호 공식: 3n² - 3n + 2

## 📖 수학적 패턴 분석 방법

### 1. 작은 케이스 분석
- n=1, 2, 3, 4, 5 등 작은 값부터 확인
- 패턴이 보이기 시작하는 지점 찾기

### 2. 규칙 찾기
- 등차수열: 공차가 일정
- 등비수열: 공비가 일정
- 계차수열: 차이가 일정한 수열

### 3. 공식 도출
- 일반항 찾기
- 합 공식 찾기
- 재귀 관계식 찾기

### 4. 검증
- 작은 케이스로 공식 검증
- 경계 조건 확인

## 💻 수학 함수 활용

### math 모듈
```python
import math

# 올림
math.ceil(3.2)  # 4

# 내림
math.floor(3.8)  # 3

# 제곱근
math.sqrt(16)  # 4.0

# 거듭제곱
math.pow(2, 3)  # 8.0
```

### 정수 연산으로 올림 구현
```python
# n을 m으로 나눈 결과를 올림
result = (n + m - 1) // m

# 예시
(10 + 3 - 1) // 3  # 4 (10/3 = 3.33... → 4)
```

